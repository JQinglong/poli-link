'use strict';

const ufo = require('ufo');
const fsExtra = require('fs-extra');
const upath = require('upath');
const crypto = require('crypto');
const MagicString = require('magic-string');
const estreeWalker = require('estree-walker');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
const MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);

var name = "@nuxtjs/composition-api";
var version = "0.22.4";

function prepareUseStatic() {
  const nuxtOptions = this.nuxt.options;
  const staticPath = upath.join(nuxtOptions.buildDir, "static-json");
  this.nuxt.hook("builder:prepared", () => {
    fsExtra.mkdirpSync(staticPath);
  });
  this.nuxt.hook("generate:route", () => {
    fsExtra.mkdirpSync(staticPath);
  });
  this.nuxt.hook("generate:done", async (generator) => {
    if (!fsExtra.existsSync(staticPath))
      return;
    const {distPath} = generator;
    fsExtra.readdirSync(staticPath).forEach((file) => fsExtra.copyFileSync(upath.join(staticPath, file), upath.join(distPath, file)));
  });
  return {staticPath};
}

function isFullStatic(options) {
  var _a;
  return !options.dev && !options._legacyGenerate && options.target === "static" && ((_a = options.render) == null ? void 0 : _a.ssr);
}
function isUrl(url) {
  return ["http", "//"].some((str) => url.startsWith(str));
}
function resolveRelativePath(id) {
  let src;
  try {
    src = require.resolve(`@nuxtjs/composition-api/${id}`);
  } catch (e) {
    src = require.resolve(upath.join(__dirname, `./${id}`));
  }
  return src;
}
function addResolvedTemplate(template, options = {}) {
  const nuxtOptions = this.nuxt.options;
  const src = resolveRelativePath(template);
  const {dst} = this.addTemplate({
    src,
    fileName: upath.join("composition-api", upath.basename(src)),
    options
  });
  const templatePath = upath.join(nuxtOptions.buildDir, dst);
  return templatePath;
}
function resolveCoreJsVersion() {
  let corejsPolyfill = this.nuxt.options.build.corejs ? String(this.nuxt.options.build.corejs) : void 0;
  try {
    if (!["2", "3"].includes(corejsPolyfill || "")) {
      const corejsPkg = this.nuxt.resolver.requireModule("core-js/package.json");
      corejsPolyfill = corejsPkg.version.slice(0, 1);
    }
  } catch (e) {
    corejsPolyfill = void 0;
  }
  return corejsPolyfill;
}
function getNuxtGlobals() {
  const nuxtOptions = this.nuxt.options;
  const globalName = nuxtOptions.globalName;
  const globalContextFactory = nuxtOptions.globals.context || ((globalName2) => `__${globalName2.toUpperCase()}__`);
  const globalNuxtFactory = nuxtOptions.globals.nuxt || ((globalName2) => `$${globalName2}`);
  const globalContext = globalContextFactory(globalName);
  const globalNuxt = globalNuxtFactory(globalName);
  return {globalContext, globalNuxt};
}

function createKey(source, method = "base64") {
  const hash = crypto__default['default'].createHash("md5");
  hash.update(source);
  return hash.digest(method).toString();
}
function compositionApiPlugin() {
  return {
    name: "nuxt:composition-api",
    enforce: "pre",
    transform(code, filename) {
      code = code.replace(/@nuxtjs[\\/]composition-api/g, "~nuxtjs-composition-api");
      const keyedFunctions = /(useStatic|shallowSsrRef|ssrPromise|ssrRef|reqSsrRef|useAsync)/;
      if (!keyedFunctions.test(code)) {
        return {
          code,
          map: null
        };
      }
      try {
        const {0: script = code, index: codeIndex = 0} = code.match(/(?<=<script[^>]*>)[\S\s.]*?(?=<\/script>)/) || [];
        const ast = this.parse(script);
        const s = new MagicString__default['default'](code);
        estreeWalker.walk(ast, {
          enter(node) {
            var _a, _b;
            const {end} = node;
            const {callee, arguments: args = []} = node;
            if ((callee == null ? void 0 : callee.type) === "Identifier" || ((_a = callee == null ? void 0 : callee.property) == null ? void 0 : _a.type) === "Identifier") {
              let method = "base64";
              switch (callee.name || ((_b = callee.property) == null ? void 0 : _b.name)) {
                case "useStatic":
                  if (args.length > 2)
                    return;
                  if (args.length === 2) {
                    s.prependLeft(codeIndex + end - 1, ", undefined");
                  }
                  method = "hex";
                  break;
                case "shallowSsrRef":
                case "ssrPromise":
                case "ssrRef":
                case "reqSsrRef":
                case "useAsync":
                  if (args.length > 1)
                    return;
                  break;
                default:
                  return;
              }
              s.appendLeft(codeIndex + end - 1, ", '" + createKey(`${filename}-${end}`, method) + "'");
            }
          }
        });
        return {
          code: s.toString(),
          map: s.generateMap().toString()
        };
      } catch (e) {
      }
    }
  };
}

function registerBabelPlugin() {
  const nuxtOptions = this.nuxt.options;
  nuxtOptions.build.babel = nuxtOptions.build.babel || {};
  nuxtOptions.build.babel.plugins = nuxtOptions.build.babel.plugins || [];
  if (nuxtOptions.build.babel.plugins instanceof Function) {
    console.warn("Unable to automatically add Babel plugin. Make sure your custom `build.babel.plugins` returns `@nuxtjs/composition-api/babel`");
  } else {
    nuxtOptions.build.babel.plugins.push(resolveRelativePath("babel"));
  }
  const actualPresets = nuxtOptions.build.babel.presets;
  nuxtOptions.build.babel.presets = (env, [defaultPreset, defaultOptions]) => {
    const newOptions = {
      ...defaultOptions,
      jsx: {
        ...typeof defaultOptions.jsx === "object" ? defaultOptions.jsx : {},
        compositionAPI: true
      }
    };
    if (typeof actualPresets === "function") {
      return actualPresets(env, [defaultPreset, newOptions]);
    }
    return [[defaultPreset, newOptions]];
  };
}

const compositionApiModule = function compositionApiModule2() {
  const nuxtOptions = this.nuxt.options;
  const {staticPath} = prepareUseStatic.call(this);
  const {globalContext, globalNuxt} = getNuxtGlobals.call(this);
  const routerBase = ufo.withTrailingSlash(nuxtOptions.router.base);
  const publicPath = ufo.withTrailingSlash(nuxtOptions.build.publicPath);
  const entryFile = addResolvedTemplate.call(this, "entrypoint", {
    isFullStatic: isFullStatic(nuxtOptions),
    staticPath,
    publicPath: isUrl(publicPath) ? publicPath : routerBase,
    globalContext,
    globalNuxt
  });
  nuxtOptions.alias["@nuxtjs/composition-api"] = entryFile;
  nuxtOptions.build.transpile = nuxtOptions.build.transpile || [];
  nuxtOptions.build.transpile.push("@nuxtjs/composition-api");
  if (!nuxtOptions.dev) {
    nuxtOptions.build.transpile.push("@vue/composition-api");
  }
  this.nuxt.hook("vite:extend", (ctx) => {
    ctx.config.plugins.push(compositionApiPlugin());
    ctx.config.optimizeDeps.exclude.push("@vue/composition-api");
    ctx.config.resolve.alias["~nuxtjs-composition-api"] = entryFile;
  });
  registerBabelPlugin.call(this);
  addResolvedTemplate.call(this, "templates/polyfill.client.js", {
    corejsPolyfill: resolveCoreJsVersion.call(this)
  });
  const globalPlugin = addResolvedTemplate.call(this, "templates/plugin.js");
  this.nuxt.hook("modules:done", () => {
    nuxtOptions.plugins.unshift(globalPlugin);
  });
  if (!nuxtOptions.buildModules.includes("@nuxtjs/pwa") && !nuxtOptions.modules.includes("@nuxtjs/pwa")) {
    nuxtOptions.plugins.push(addResolvedTemplate.call(this, "templates/meta.js"));
  } else if (nuxtOptions.dev) {
    console.warn("useMeta is not supported in onGlobalSetup as @nuxtjs/pwa detected.\nSee https://github.com/nuxt-community/composition-api/issues/307");
  }
};
compositionApiModule.meta = {
  name,
  version
};
const warnToAddModule = () => {
  console.error("You need to add `@nuxtjs/composition-api` to your buildModules in order to use it. See https://composition-api.nuxtjs.org/getting-started/setup.");
  throw new Error("You need to add `@nuxtjs/composition-api` to your buildModules in order to use it. See https://composition-api.nuxtjs.org/getting-started/setup.");
};
const helperFunctions = JSON.parse(`["useAsync","useContext","withContext","useFetch","globalPlugin","onGlobalSetup","setMetaPlugin","useMeta","reqRef","reqSsrRef","ssrRef","shallowSsrRef","setSSRContext","ssrPromise","useStatic","defineNuxtPlugin","defineNuxtMiddleware","defineNuxtModule","defineNuxtServerMiddleware","defineNuxtConfig","wrapProperty","useRouter","useRoute","useStore","defineComponent","computed","createApp","createRef","customRef","defineAsyncComponent","del","getCurrentInstance","h","inject","isRaw","isReactive","isReadonly","isRef","markRaw","nextTick","onActivated","onBeforeMount","onBeforeUnmount","onBeforeUpdate","onDeactivated","onErrorCaptured","onMounted","onServerPrefetch","onUnmounted","onUpdated","provide","proxyRefs","reactive","readonly","ref","set","shallowReactive","shallowReadonly","shallowRef","toRaw","toRef","toRefs","triggerRef","unref","useCssModule","useCSSModule","version","warn","watch","watchEffect"]`);
helperFunctions.forEach((helper) => {
  compositionApiModule[helper] = warnToAddModule;
});
compositionApiModule.defineNuxtConfig = (config) => config;
compositionApiModule.defineServerMiddleware = (smw) => smw;
compositionApiModule.defineNuxtModule = (mod) => mod;

module.exports = compositionApiModule;
